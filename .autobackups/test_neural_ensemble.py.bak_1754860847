import pytest
import numpy as np
from unittest.mock import patch, MagicMock
from core.strategies.neural_ensemble import NeuralEnsembleStrategy

@pytest.fixture(params=[
    {'ensemble_type': 'conservative', 'expected_max_vol': 0.3},
    {'ensemble_type': 'aggressive', 'expected_max_vol': 0.5},
    {'ensemble_type': 'market_neutral', 'expected_max_vol': 0.2},
], ids=['conservative', 'aggressive', 'market_neutral'])
def configured_strategy(request):
    cfg = {
        'ensemble_config': {
            'type': request.param['ensemble_type'],
            'max_volatility': request.param['expected_max_vol'],
        }
    }
    return NeuralEnsembleStrategy(cfg)

@pytest.fixture
def mock_models():
    return {
        'temporal': MagicMock(),
        'graph': MagicMock(),
        'fundamental': MagicMock(),
    }

class TestEnsembleWeighting:
    @pytest.mark.parametrize(
        "stds, expected_order",
        [
            ([0.1, 0.4, 0.6], ['temporal', 'graph', 'fundamental']),
            ([0.4, 0.1, 0.6], ['graph', 'temporal', 'fundamental']),
            ([0.6, 0.4, 0.1], ['fundamental', 'graph', 'temporal']),
        ],
        ids=["temp>graph>fund", "graph>temp>fund", "fund>graph>temp"],
    )
    def test_uncertainty_weighting_order(self, configured_strategy, mock_models, stds, expected_order):
        for (name, model), std in zip(mock_models.items(), stds):
            model.predict_with_uncertainty.return_value = {'mean': 0.5, 'std': std}

        with patch.object(configured_strategy, 'models', mock_models):
            signal = configured_strategy.generate_signal({})

        # Accept either a 'weights' dict or individual '*_weight' keys
        weights = {}
        if isinstance(signal, dict) and isinstance(signal.get('weights'), dict):
            weights = signal['weights']
        else:
            for name in mock_models:
                k = f"{name}_weight"
                if isinstance(signal, dict) and k in signal:
                    weights[name] = signal[k]

        assert weights, "Strategy output must include weights (either 'weights' dict or '*_weight' keys')"

        order = sorted(weights.keys(), key=lambda k: weights[k], reverse=True)
        assert order == expected_order, f"Expected order {expected_order}, got {order}"
